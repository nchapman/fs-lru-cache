{"version":3,"file":"index.cjs","names":["entry: MemoryEntry","result: string[]","gzip","gunzip","files: string[]","data: CacheEntry","entry: CacheEntry<T>","result: string[]","expiredKeys: string[]","entry: CacheEntry","expired: string[]","oldestKey: string | null"],"sources":["../src/types.ts","../src/utils.ts","../src/memory-store.ts","../src/file-store.ts","../src/cache.ts"],"sourcesContent":["/**\n * Configuration options for FsLruCache\n *\n * @remarks\n * **Known Limitations:**\n * - `null` values cannot be distinguished from cache misses (both return `null`).\n *   Use a sentinel value like `{ notFound: true }` to cache negative lookups.\n * - Values must be JSON-serializable (no functions, undefined, circular refs).\n */\nexport interface CacheOptions {\n  /** Cache directory path (default: ./.cache) */\n  dir?: string;\n  /** Maximum number of items in memory (default: 1000) */\n  maxMemoryItems?: number;\n  /** Maximum memory usage in bytes (default: 50MB). Values larger than this skip the memory tier. */\n  maxMemorySize?: number;\n  /** Maximum disk usage in bytes (default: 500MB) */\n  maxDiskSize?: number;\n  /** Number of shard directories (default: 16) */\n  shards?: number;\n  /** Default TTL in seconds for all entries (default: none). Use 0 to explicitly disable TTL on a specific set(). */\n  defaultTtl?: number;\n  /** Namespace prefix for all keys (default: none). Keys are stored as `${namespace}:${key}`. */\n  namespace?: string;\n  /** Enable gzip compression for disk storage (default: false). Reduces disk usage at the cost of CPU. */\n  gzip?: boolean;\n  /** Interval in milliseconds for automatic pruning of expired items (default: disabled). */\n  pruneInterval?: number;\n}\n\nexport interface CacheEntry<T = unknown> {\n  /** The cache key */\n  key: string;\n  /** The stored value */\n  value: T;\n  /** Expiration timestamp in ms, or null if no expiry */\n  expiresAt: number | null;\n}\n\nexport interface MemoryEntry {\n  /** The cache key */\n  key: string;\n  /** JSON-serialized value */\n  serialized: string;\n  /** Expiration timestamp in ms, or null if no expiry */\n  expiresAt: number | null;\n  /** Size in bytes */\n  size: number;\n}\n\nexport interface CacheStats {\n  /** Total cache hits */\n  hits: number;\n  /** Total cache misses */\n  misses: number;\n  /** Hit rate (0-1) */\n  hitRate: number;\n  /** Memory store statistics */\n  memory: {\n    items: number;\n    size: number;\n    maxItems: number;\n    maxSize: number;\n  };\n  /** Disk store statistics */\n  disk: {\n    items: number;\n    size: number;\n  };\n}\n\nexport const DEFAULT_OPTIONS = {\n  dir: \".cache\",\n  maxMemoryItems: 1000,\n  maxMemorySize: 50 * 1024 * 1024, // 50MB\n  maxDiskSize: 500 * 1024 * 1024, // 500MB\n  shards: 16,\n  defaultTtl: undefined as number | undefined,\n  namespace: undefined as string | undefined,\n  gzip: false,\n  pruneInterval: undefined as number | undefined,\n};\n","import { createHash } from \"crypto\";\n\n/**\n * Generate a hash for a cache key.\n * Returns a 32-character hex string (128 bits - collision resistant to ~2^64 keys)\n */\nexport function hashKey(key: string): string {\n  return createHash(\"sha256\").update(key).digest(\"hex\").slice(0, 32);\n}\n\n/**\n * Get the shard index from a hash\n */\nexport function getShardIndex(hash: string, shardCount: number): number {\n  return parseInt(hash.slice(0, 8), 16) % shardCount;\n}\n\n/**\n * Get shard directory name (2-char hex)\n */\nexport function getShardName(index: number): string {\n  return index.toString(16).padStart(2, \"0\");\n}\n\n/**\n * Check if a cache entry has expired\n */\nexport function isExpired(expiresAt: number | null): boolean {\n  return expiresAt !== null && Date.now() > expiresAt;\n}\n\n/**\n * Compile a glob pattern to a RegExp for efficient reuse.\n * Returns null for '*' (match all) as an optimization.\n */\nexport function compilePattern(pattern: string): RegExp | null {\n  if (pattern === \"*\") return null;\n  const collapsed = pattern.replace(/\\*+/g, \"*\");\n  const escaped = collapsed.replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\*/g, \".*\");\n  return new RegExp(`^${escaped}$`);\n}\n\n/**\n * Test if a key matches a pattern.\n * Accepts a pre-compiled RegExp, a string pattern, or null (match all).\n */\nexport function matchPattern(key: string, pattern: string | RegExp | null): boolean {\n  if (pattern === null || pattern === \"*\") return true;\n  if (pattern instanceof RegExp) return pattern.test(key);\n  return compilePattern(pattern)!.test(key);\n}\n","import { MemoryEntry } from \"./types.js\";\nimport { isExpired, compilePattern, matchPattern } from \"./utils.js\";\n\nexport interface MemoryStoreOptions {\n  maxItems: number;\n  maxSize: number;\n}\n\n/**\n * In-memory LRU cache using Map for O(1) operations.\n * Map maintains insertion order, enabling LRU tracking via re-insertion.\n */\nexport class MemoryStore {\n  private cache = new Map<string, MemoryEntry>();\n  private currentSize = 0;\n  private readonly maxItems: number;\n  private readonly maxSize: number;\n\n  constructor(options: MemoryStoreOptions) {\n    this.maxItems = options.maxItems;\n    this.maxSize = options.maxSize;\n  }\n\n  /**\n   * Get entry if it exists and isn't expired, removing expired entries.\n   * Returns null if not found or expired.\n   */\n  private getValidEntry(key: string): MemoryEntry | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n    if (isExpired(entry.expiresAt)) {\n      this.delete(key);\n      return null;\n    }\n    return entry;\n  }\n\n  /**\n   * Get a serialized value from the cache.\n   * Promotes the key to most recently used on access.\n   * @returns The JSON-serialized value string, or null if not found\n   */\n  get(key: string): string | null {\n    const entry = this.getValidEntry(key);\n    if (!entry) return null;\n\n    // Promote to most recently used by re-inserting\n    this.cache.delete(key);\n    this.cache.set(key, entry);\n    return entry.serialized;\n  }\n\n  /**\n   * Get entry metadata without promoting (peek doesn't affect LRU order)\n   */\n  peek(key: string): MemoryEntry | null {\n    return this.getValidEntry(key);\n  }\n\n  /**\n   * Set a serialized value in the cache\n   * @param key The cache key\n   * @param serialized The JSON-serialized value string\n   * @param expiresAt Expiration timestamp or null\n   */\n  set(key: string, serialized: string, expiresAt: number | null = null): void {\n    if (this.cache.has(key)) {\n      this.delete(key);\n    }\n\n    const size = Buffer.byteLength(serialized, \"utf8\");\n    const entry: MemoryEntry = { key, serialized, expiresAt, size };\n\n    // Evict until we have space\n    while (this.needsEviction(size)) {\n      this.evictOne();\n    }\n\n    this.cache.set(key, entry);\n    this.currentSize += size;\n  }\n\n  /**\n   * Delete a key from the cache\n   */\n  delete(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n\n    this.cache.delete(key);\n    this.currentSize -= entry.size;\n    return true;\n  }\n\n  /**\n   * Check if a key exists (and is not expired)\n   */\n  has(key: string): boolean {\n    return this.getValidEntry(key) !== null;\n  }\n\n  /**\n   * Get all keys matching a pattern\n   */\n  keys(pattern = \"*\"): string[] {\n    const compiled = compilePattern(pattern);\n    const result: string[] = [];\n\n    for (const [key, entry] of this.cache) {\n      if (isExpired(entry.expiresAt)) {\n        this.delete(key);\n      } else if (matchPattern(key, compiled)) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Update expiration time for a key\n   */\n  setExpiry(key: string, expiresAt: number | null): boolean {\n    const entry = this.getValidEntry(key);\n    if (!entry) return false;\n\n    entry.expiresAt = expiresAt;\n    return true;\n  }\n\n  /**\n   * Touch a key: promote to most recently used.\n   * Does not read or return the value.\n   */\n  touch(key: string): boolean {\n    const entry = this.getValidEntry(key);\n    if (!entry) return false;\n\n    // Promote to most recently used by re-inserting\n    this.cache.delete(key);\n    this.cache.set(key, entry);\n    return true;\n  }\n\n  /**\n   * Get TTL for a key in milliseconds.\n   * Returns -1 if no expiry, -2 if not found.\n   */\n  getTtl(key: string): number {\n    const entry = this.getValidEntry(key);\n    if (!entry) return -2;\n    if (entry.expiresAt === null) return -1;\n    return Math.max(0, entry.expiresAt - Date.now());\n  }\n\n  /**\n   * Clear all entries\n   */\n  clear(): void {\n    this.cache.clear();\n    this.currentSize = 0;\n  }\n\n  /**\n   * Remove all expired entries from the cache.\n   * @returns Number of entries removed\n   */\n  prune(): number {\n    const now = Date.now();\n    let count = 0;\n\n    for (const [key, entry] of this.cache) {\n      if (entry.expiresAt !== null && entry.expiresAt <= now) {\n        this.delete(key);\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  /**\n   * Get current stats\n   */\n  get stats() {\n    return {\n      items: this.cache.size,\n      size: this.currentSize,\n      maxItems: this.maxItems,\n      maxSize: this.maxSize,\n    };\n  }\n\n  /**\n   * Check if eviction is needed to accommodate new data\n   */\n  private needsEviction(newSize: number): boolean {\n    return (\n      this.cache.size > 0 &&\n      (this.cache.size >= this.maxItems || this.currentSize + newSize > this.maxSize)\n    );\n  }\n\n  /**\n   * Evict an entry to make room for new data.\n   * Priority: expired items first, then LRU (oldest in map).\n   */\n  private evictOne(): void {\n    // First pass: find an expired entry\n    for (const [key, entry] of this.cache) {\n      if (isExpired(entry.expiresAt)) {\n        this.delete(key);\n        return;\n      }\n    }\n\n    // No expired entries: evict LRU (first entry in map)\n    const oldest = this.cache.keys().next().value;\n    if (oldest !== undefined) {\n      this.delete(oldest);\n    }\n  }\n}\n","import { promises as fs } from \"fs\";\nimport { join } from \"path\";\nimport { randomBytes } from \"crypto\";\nimport { gzip, gunzip } from \"zlib\";\nimport { promisify } from \"util\";\nimport { CacheEntry } from \"./types.js\";\n\nconst gzipAsync = promisify(gzip);\nconst gunzipAsync = promisify(gunzip);\nimport {\n  hashKey,\n  getShardIndex,\n  getShardName,\n  isExpired,\n  compilePattern,\n  matchPattern,\n} from \"./utils.js\";\n\n/** Gzip magic bytes for detecting compressed files */\nconst GZIP_MAGIC = Buffer.from([0x1f, 0x8b]);\n\nexport interface FileStoreOptions {\n  dir: string;\n  shards: number;\n  maxSize: number;\n  gzip?: boolean;\n  /**\n   * Called synchronously when a key is evicted due to:\n   * - Hash collision (another key claims the same hash)\n   * - Space pressure (LRU eviction to stay under maxSize)\n   *\n   * NOT called for explicit delete() operations.\n   * This allows the parent to keep other caches in sync.\n   */\n  onEvict?: (key: string) => void;\n}\n\ninterface IndexEntry {\n  hash: string;\n  expiresAt: number | null;\n  lastAccessedAt: number;\n  size: number;\n}\n\n/**\n * File system storage layer with sharding and in-memory index.\n */\nexport class FileStore {\n  private readonly dir: string;\n  private readonly shards: number;\n  private readonly maxSize: number;\n  private readonly gzip: boolean;\n  private readonly onEvict?: (key: string) => void;\n  private initialized = false;\n\n  // In-memory index: key -> metadata (no values, just for fast lookups)\n  private index = new Map<string, IndexEntry>();\n  // Reverse mapping: hash -> key (to detect collisions)\n  private hashToKey = new Map<string, string>();\n  private totalSize = 0;\n\n  constructor(options: FileStoreOptions) {\n    this.dir = options.dir;\n    this.shards = options.shards;\n    this.maxSize = options.maxSize;\n    this.gzip = options.gzip ?? false;\n    this.onEvict = options.onEvict;\n  }\n\n  /**\n   * Check if a buffer is gzip compressed by looking for magic bytes.\n   */\n  private isCompressed(data: Buffer): boolean {\n    return data.length >= 2 && data[0] === GZIP_MAGIC[0] && data[1] === GZIP_MAGIC[1];\n  }\n\n  /**\n   * Compress data if compression is enabled.\n   */\n  private async compress(data: string): Promise<Buffer> {\n    const buffer = Buffer.from(data, \"utf8\");\n    return this.gzip ? gzipAsync(buffer) : buffer;\n  }\n\n  /**\n   * Decompress data, auto-detecting if it's compressed.\n   */\n  private async decompress(data: Buffer): Promise<string> {\n    if (this.isCompressed(data)) {\n      const decompressed = await gunzipAsync(data);\n      return decompressed.toString(\"utf8\");\n    }\n    return data.toString(\"utf8\");\n  }\n\n  /**\n   * Initialize the cache directory structure and load index\n   */\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    await fs.mkdir(this.dir, { recursive: true });\n\n    // Create shard directories\n    const shardPromises = Array.from({ length: this.shards }, (_, i) =>\n      fs.mkdir(join(this.dir, getShardName(i)), { recursive: true }),\n    );\n    await Promise.all(shardPromises);\n\n    await this.loadIndex();\n    this.initialized = true;\n  }\n\n  /**\n   * Load index from disk (scans all files once on startup)\n   */\n  private async loadIndex(): Promise<void> {\n    this.index.clear();\n    this.hashToKey.clear();\n    this.totalSize = 0;\n\n    const loadShard = async (shardIndex: number) => {\n      const shardDir = join(this.dir, getShardName(shardIndex));\n      let files: string[];\n\n      try {\n        files = await fs.readdir(shardDir);\n      } catch {\n        return; // Shard doesn't exist yet\n      }\n\n      for (const file of files) {\n        if (!file.endsWith(\".json\")) continue;\n        await this.loadFile(shardDir, file);\n      }\n    };\n\n    await Promise.all(Array.from({ length: this.shards }, (_, i) => loadShard(i)));\n  }\n\n  /**\n   * Load a single cache file into the index\n   */\n  private async loadFile(shardDir: string, file: string): Promise<void> {\n    const filePath = join(shardDir, file);\n\n    try {\n      const [stat, rawContent] = await Promise.all([fs.stat(filePath), fs.readFile(filePath)]);\n      const content = await this.decompress(rawContent);\n      const data: CacheEntry = JSON.parse(content);\n\n      if (isExpired(data.expiresAt)) {\n        await fs.unlink(filePath).catch(() => {});\n        return;\n      }\n\n      const hash = file.replace(\".json\", \"\");\n      this.index.set(data.key, {\n        hash,\n        expiresAt: data.expiresAt,\n        lastAccessedAt: stat.mtimeMs,\n        size: stat.size,\n      });\n      this.hashToKey.set(hash, data.key);\n      this.totalSize += stat.size;\n    } catch {\n      // Skip invalid files\n    }\n  }\n\n  /**\n   * Get the file path for a hash\n   */\n  private getFilePath(hash: string): string {\n    const shardName = getShardName(getShardIndex(hash, this.shards));\n    return join(this.dir, shardName, `${hash}.json`);\n  }\n\n  /**\n   * Generate a temporary file path for atomic writes\n   */\n  private getTempPath(): string {\n    return join(this.dir, `.tmp-${randomBytes(8).toString(\"hex\")}`);\n  }\n\n  /**\n   * Atomic file write: write to temp, then rename\n   */\n  private async atomicWrite(filePath: string, content: Buffer): Promise<void> {\n    const tempPath = this.getTempPath();\n    try {\n      await fs.writeFile(tempPath, content);\n      await fs.rename(tempPath, filePath);\n    } catch (err) {\n      await fs.unlink(tempPath).catch(() => {});\n      throw err;\n    }\n  }\n\n  /**\n   * Get a valid index entry, removing it if expired\n   */\n  private async getValidIndexEntry(key: string): Promise<IndexEntry | null> {\n    const entry = this.index.get(key);\n    if (!entry) return null;\n\n    if (isExpired(entry.expiresAt)) {\n      await this.delete(key);\n      return null;\n    }\n    return entry;\n  }\n\n  /**\n   * Read and parse a cache file, handling errors and key mismatches\n   */\n  private async readCacheFile<T>(\n    key: string,\n    indexEntry: IndexEntry,\n  ): Promise<CacheEntry<T> | null> {\n    const filePath = this.getFilePath(indexEntry.hash);\n\n    try {\n      const rawContent = await fs.readFile(filePath);\n      const content = await this.decompress(rawContent);\n      const entry: CacheEntry<T> = JSON.parse(content);\n\n      // Verify key matches (hash collision check)\n      if (entry.key !== key) {\n        this.index.delete(key);\n        return null;\n      }\n      return entry;\n    } catch {\n      // File missing or corrupted - clean up index\n      this.totalSize -= indexEntry.size;\n      this.index.delete(key);\n      this.hashToKey.delete(indexEntry.hash);\n      return null;\n    }\n  }\n\n  /**\n   * Get a value from disk.\n   * Returns the full cache entry for consistency with memory store.\n   */\n  async get<T = unknown>(key: string): Promise<CacheEntry<T> | null> {\n    await this.init();\n\n    const indexEntry = await this.getValidIndexEntry(key);\n    if (!indexEntry) return null;\n\n    const entry = await this.readCacheFile<T>(key, indexEntry);\n    if (entry) {\n      indexEntry.lastAccessedAt = Date.now();\n    }\n    return entry;\n  }\n\n  /**\n   * Get entry metadata without updating access time\n   */\n  async peek(key: string): Promise<CacheEntry | null> {\n    await this.init();\n\n    const indexEntry = await this.getValidIndexEntry(key);\n    if (!indexEntry) return null;\n\n    return this.readCacheFile(key, indexEntry);\n  }\n\n  /**\n   * Set a value on disk with atomic write\n   * @param content Optional pre-serialized content (to avoid double serialization)\n   */\n  async set<T = unknown>(\n    key: string,\n    value: T,\n    expiresAt: number | null = null,\n    content?: string,\n  ): Promise<void> {\n    await this.init();\n\n    // Use pre-serialized content if provided, otherwise serialize now\n    const serialized = content ?? JSON.stringify({ key, value, expiresAt } as CacheEntry<T>);\n    const compressed = await this.compress(serialized);\n    const size = compressed.length;\n    const hash = hashKey(key);\n    const filePath = this.getFilePath(hash);\n\n    // Remove old entry if exists\n    const existing = this.index.get(key);\n    if (existing) {\n      this.totalSize -= existing.size;\n      this.hashToKey.delete(existing.hash);\n    }\n\n    // Handle hash collision: if another key owns this hash, remove it\n    const collidingKey = this.hashToKey.get(hash);\n    if (collidingKey && collidingKey !== key) {\n      const collidingEntry = this.index.get(collidingKey);\n      if (collidingEntry) {\n        this.totalSize -= collidingEntry.size;\n        this.index.delete(collidingKey);\n        // Notify parent about the collision eviction (wrapped to ensure set() completes)\n        try {\n          this.onEvict?.(collidingKey);\n        } catch {\n          // Callback errors shouldn't fail the set operation\n        }\n      }\n    }\n\n    await this.ensureSpace(size);\n    await this.atomicWrite(filePath, compressed);\n\n    this.index.set(key, {\n      hash,\n      expiresAt,\n      lastAccessedAt: Date.now(),\n      size,\n    });\n    this.hashToKey.set(hash, key);\n    this.totalSize += size;\n  }\n\n  /**\n   * Delete a key from disk\n   */\n  async delete(key: string): Promise<boolean> {\n    await this.init();\n\n    const indexEntry = this.index.get(key);\n    if (!indexEntry) return false;\n\n    const filePath = this.getFilePath(indexEntry.hash);\n\n    // Update index first (before I/O)\n    this.totalSize -= indexEntry.size;\n    this.index.delete(key);\n    this.hashToKey.delete(indexEntry.hash);\n\n    try {\n      await fs.unlink(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if a key exists on disk (fast - uses index)\n   */\n  async has(key: string): Promise<boolean> {\n    await this.init();\n    return (await this.getValidIndexEntry(key)) !== null;\n  }\n\n  /**\n   * Get all keys matching a pattern (fast - uses index)\n   */\n  async keys(pattern = \"*\"): Promise<string[]> {\n    await this.init();\n\n    const compiled = compilePattern(pattern);\n    const result: string[] = [];\n    const expiredKeys: string[] = [];\n\n    for (const [key, entry] of this.index) {\n      if (isExpired(entry.expiresAt)) {\n        expiredKeys.push(key);\n      } else if (matchPattern(key, compiled)) {\n        result.push(key);\n      }\n    }\n\n    // Clean up expired entries in parallel\n    if (expiredKeys.length > 0) {\n      await Promise.all(expiredKeys.map((key) => this.delete(key)));\n    }\n\n    return result;\n  }\n\n  /**\n   * Update expiration time for a key\n   */\n  async setExpiry(key: string, expiresAt: number | null): Promise<boolean> {\n    await this.init();\n\n    const indexEntry = await this.getValidIndexEntry(key);\n    if (!indexEntry) return false;\n\n    const filePath = this.getFilePath(indexEntry.hash);\n\n    try {\n      const rawContent = await fs.readFile(filePath);\n      const content = await this.decompress(rawContent);\n      const entry: CacheEntry = JSON.parse(content);\n\n      if (entry.key !== key) return false;\n\n      entry.expiresAt = expiresAt;\n      const serialized = JSON.stringify(entry);\n      const compressed = await this.compress(serialized);\n      await this.atomicWrite(filePath, compressed);\n\n      // Update index\n      const newSize = compressed.length;\n      this.totalSize += newSize - indexEntry.size;\n      indexEntry.expiresAt = expiresAt;\n      indexEntry.size = newSize;\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get TTL for a key in milliseconds (fast - uses index).\n   * Returns -1 if no expiry, -2 if not found.\n   */\n  async getTtl(key: string): Promise<number> {\n    await this.init();\n\n    const indexEntry = await this.getValidIndexEntry(key);\n    if (!indexEntry) return -2;\n    if (indexEntry.expiresAt === null) return -1;\n    return Math.max(0, indexEntry.expiresAt - Date.now());\n  }\n\n  /**\n   * Touch a key: update last accessed time for LRU tracking.\n   * Updates both the in-memory index and file mtime (for restart persistence).\n   */\n  async touch(key: string): Promise<boolean> {\n    await this.init();\n\n    const indexEntry = await this.getValidIndexEntry(key);\n    if (!indexEntry) return false;\n\n    const filePath = this.getFilePath(indexEntry.hash);\n    const now = Date.now();\n\n    indexEntry.lastAccessedAt = now;\n\n    try {\n      const nowDate = new Date(now);\n      await fs.utimes(filePath, nowDate, nowDate);\n    } catch {\n      // File may be gone, but index update still valid for this session\n    }\n\n    return true;\n  }\n\n  /**\n   * Clear all entries\n   */\n  async clear(): Promise<void> {\n    await this.init();\n\n    const clearShard = async (shardIndex: number) => {\n      const shardDir = join(this.dir, getShardName(shardIndex));\n      try {\n        const files = await fs.readdir(shardDir);\n        await Promise.all(files.map((file) => fs.unlink(join(shardDir, file)).catch(() => {})));\n      } catch {\n        // Ignore errors\n      }\n    };\n\n    await Promise.all(Array.from({ length: this.shards }, (_, i) => clearShard(i)));\n\n    this.index.clear();\n    this.hashToKey.clear();\n    this.totalSize = 0;\n  }\n\n  /**\n   * Get total size of cache on disk (fast - uses index)\n   */\n  async getSize(): Promise<number> {\n    await this.init();\n    return this.totalSize;\n  }\n\n  /**\n   * Get number of items in cache (fast - uses index)\n   */\n  async getItemCount(): Promise<number> {\n    await this.init();\n    return this.index.size;\n  }\n\n  /**\n   * Remove all expired entries from disk.\n   * Uses the in-memory index for efficient lookup (no filesystem scan).\n   * @returns Number of entries removed\n   */\n  async prune(): Promise<number> {\n    await this.init();\n\n    const now = Date.now();\n    const expired: string[] = [];\n\n    // Collect expired keys from index\n    for (const [key, entry] of this.index) {\n      if (entry.expiresAt !== null && entry.expiresAt <= now) {\n        expired.push(key);\n      }\n    }\n\n    // Delete expired entries\n    await Promise.all(expired.map((key) => this.delete(key)));\n\n    return expired.length;\n  }\n\n  /**\n   * Ensure we have space for new data by evicting entries.\n   * Priority: expired items first, then LRU (oldest lastAccessedAt).\n   */\n  private async ensureSpace(needed: number): Promise<void> {\n    if (this.totalSize + needed <= this.maxSize) return;\n\n    const target = this.totalSize + needed - this.maxSize;\n    let freed = 0;\n    const now = Date.now();\n\n    // First pass: collect and delete all expired entries\n    const expiredKeys = Array.from(this.index.entries())\n      .filter(([, entry]) => entry.expiresAt !== null && entry.expiresAt <= now)\n      .map(([key]) => key);\n\n    for (const key of expiredKeys) {\n      if (freed >= target) return;\n      freed += await this.evictKey(key);\n    }\n\n    // Second pass: evict oldest entries until we have enough space\n    while (freed < target && this.index.size > 0) {\n      const oldestKey = this.findOldestKey();\n      if (!oldestKey) break;\n      freed += await this.evictKey(oldestKey);\n    }\n  }\n\n  /**\n   * Find the key with the oldest lastAccessedAt\n   */\n  private findOldestKey(): string | null {\n    let oldestKey: string | null = null;\n    let oldestTime = Infinity;\n\n    for (const [key, entry] of this.index) {\n      if (entry.lastAccessedAt < oldestTime) {\n        oldestTime = entry.lastAccessedAt;\n        oldestKey = key;\n      }\n    }\n    return oldestKey;\n  }\n\n  /**\n   * Evict a single key and return the freed size.\n   * Calls onEvict callback to notify parent of the eviction.\n   */\n  private async evictKey(key: string): Promise<number> {\n    const entry = this.index.get(key);\n    if (!entry) return 0;\n\n    const filePath = this.getFilePath(entry.hash);\n    const freedSize = entry.size;\n\n    this.totalSize -= entry.size;\n    this.index.delete(key);\n    this.hashToKey.delete(entry.hash);\n\n    // Notify parent before disk I/O (wrapped to ensure cleanup completes)\n    try {\n      this.onEvict?.(key);\n    } catch {\n      // Callback errors shouldn't fail the eviction\n    }\n\n    try {\n      await fs.unlink(filePath);\n    } catch {\n      // File may already be gone\n    }\n\n    return freedSize;\n  }\n}\n","import { CacheOptions, CacheEntry, CacheStats, DEFAULT_OPTIONS } from \"./types.js\";\nimport { MemoryStore } from \"./memory-store.js\";\nimport { FileStore } from \"./file-store.js\";\n\n/**\n * FsLruCache - An LRU cache with file system persistence.\n *\n * Features:\n * - Two-tier storage: hot items in memory, all items on disk\n * - Memory-first reads for fast access to frequently used data\n * - Write-through to disk for durability\n * - LRU eviction in both memory and disk stores\n * - TTL support with lazy expiration\n * - Stampede protection for concurrent operations\n */\nexport class FsLruCache {\n  private readonly memory: MemoryStore;\n  private readonly files: FileStore;\n  private readonly maxMemorySize: number;\n  private readonly defaultTtl?: number;\n  private readonly namespace?: string;\n  private hits = 0;\n  private misses = 0;\n  private closed = false;\n\n  // In-flight operations for stampede protection\n  private inFlight = new Map<string, Promise<unknown>>();\n\n  // Background prune interval\n  private pruneTimer?: ReturnType<typeof setInterval>;\n\n  // Debounced touch timers for file store LRU updates\n  private touchTimers = new Map<string, ReturnType<typeof setTimeout>>();\n  private readonly touchDebounceMs = 5000;\n\n  constructor(options: CacheOptions = {}) {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    this.maxMemorySize = opts.maxMemorySize;\n    this.defaultTtl = opts.defaultTtl;\n    this.namespace = opts.namespace;\n\n    this.memory = new MemoryStore({\n      maxItems: opts.maxMemoryItems,\n      maxSize: opts.maxMemorySize,\n    });\n\n    this.files = new FileStore({\n      dir: opts.dir,\n      shards: opts.shards,\n      maxSize: opts.maxDiskSize,\n      gzip: opts.gzip,\n      // Keep memory in sync: when disk evicts a key, remove from memory too.\n      // This ensures memory is always a subset of disk (source of truth).\n      onEvict: (key) => {\n        this.memory.delete(key);\n        this.cancelDebouncedTouch(key);\n      },\n    });\n\n    // Start background pruning if configured\n    if (opts.pruneInterval && opts.pruneInterval > 0) {\n      this.pruneTimer = setInterval(() => {\n        this.prune().catch(() => {});\n      }, opts.pruneInterval);\n      // Don't keep the process alive just for pruning\n      this.pruneTimer.unref();\n    }\n  }\n\n  /**\n   * Prefix a key with the namespace if configured.\n   */\n  private prefixKey(key: string): string {\n    return this.namespace ? `${this.namespace}:${key}` : key;\n  }\n\n  /**\n   * Remove the namespace prefix from a key.\n   */\n  private unprefixKey(key: string): string {\n    if (this.namespace && key.startsWith(`${this.namespace}:`)) {\n      return key.slice(this.namespace.length + 1);\n    }\n    return key;\n  }\n\n  /**\n   * Resolve the TTL to use: explicit value, defaultTtl, or none.\n   * - undefined: use defaultTtl if set\n   * - 0: explicitly no TTL\n   * - positive number: use that TTL (in seconds)\n   * Returns milliseconds for internal use.\n   */\n  private resolveTtl(ttlSeconds?: number): number | undefined {\n    if (ttlSeconds === undefined) {\n      return this.defaultTtl ? this.defaultTtl * 1000 : undefined;\n    }\n    return ttlSeconds === 0 ? undefined : ttlSeconds * 1000;\n  }\n\n  private assertOpen(): void {\n    if (this.closed) {\n      throw new Error(\"Cache is closed\");\n    }\n  }\n\n  /**\n   * Schedule a debounced touch for the file store.\n   * Coalesces frequent accesses to reduce disk I/O.\n   */\n  private debouncedFileTouch(key: string): void {\n    if (this.touchTimers.has(key)) return;\n\n    const timer = setTimeout(() => {\n      this.touchTimers.delete(key);\n      if (!this.closed) {\n        this.files.touch(key).catch(() => {});\n      }\n    }, this.touchDebounceMs);\n\n    timer.unref();\n    this.touchTimers.set(key, timer);\n  }\n\n  /**\n   * Cancel a pending debounced touch (used on delete/eviction).\n   */\n  private cancelDebouncedTouch(key: string): void {\n    const timer = this.touchTimers.get(key);\n    if (timer) {\n      clearTimeout(timer);\n      this.touchTimers.delete(key);\n    }\n  }\n\n  /**\n   * Execute an operation with stampede protection.\n   * Concurrent calls for the same key will share the same promise.\n   */\n  private async withStampedeProtection<T>(key: string, operation: () => Promise<T>): Promise<T> {\n    const existing = this.inFlight.get(key);\n    if (existing) {\n      return existing as Promise<T>;\n    }\n\n    const promise = operation();\n    this.inFlight.set(key, promise);\n\n    try {\n      return await promise;\n    } finally {\n      this.inFlight.delete(key);\n    }\n  }\n\n  /**\n   * Get a value from the cache.\n   * Checks memory first, then disk (promoting to memory on hit).\n   */\n  async get<T = unknown>(key: string): Promise<T | null> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n\n    // Check memory first (returns JSON string)\n    const memSerialized = this.memory.get(prefixedKey);\n    if (memSerialized !== null) {\n      this.hits++;\n      // Update file store LRU (debounced to reduce I/O)\n      this.debouncedFileTouch(prefixedKey);\n      return JSON.parse(memSerialized) as T;\n    }\n\n    // Check disk (file store updates its own LRU on get)\n    const diskEntry = await this.files.get<T>(prefixedKey);\n    if (diskEntry !== null) {\n      this.hits++;\n      // Promote to memory if it fits\n      const serialized = JSON.stringify(diskEntry.value);\n      if (Buffer.byteLength(serialized, \"utf8\") <= this.maxMemorySize) {\n        this.memory.set(prefixedKey, serialized, diskEntry.expiresAt);\n      }\n      return diskEntry.value;\n    }\n\n    this.misses++;\n    return null;\n  }\n\n  /**\n   * Set a value in the cache.\n   * @param key The cache key\n   * @param value The value to store (must be JSON-serializable)\n   * @param ttl Optional TTL in seconds (0 to explicitly disable defaultTtl)\n   */\n  async set(key: string, value: unknown, ttl?: number): Promise<void> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n    const resolvedTtl = this.resolveTtl(ttl);\n\n    const expiresAt = resolvedTtl ? Date.now() + resolvedTtl : null;\n\n    // Serialize value once, reuse for both memory and disk\n    const valueSerialized = JSON.stringify(value);\n\n    // Guard against non-JSON-serializable values (undefined, functions, symbols)\n    // JSON.stringify returns undefined for these, which would produce invalid JSON\n    if (valueSerialized === undefined) {\n      throw new TypeError(\n        `Cannot cache value of type ${typeof value}. Value must be JSON-serializable.`,\n      );\n    }\n\n    const valueSize = Buffer.byteLength(valueSerialized, \"utf8\");\n\n    // Build disk entry JSON using already-serialized value (avoids double serialization)\n    const entrySerialized = `{\"key\":${JSON.stringify(prefixedKey)},\"value\":${valueSerialized},\"expiresAt\":${expiresAt}}`;\n\n    // Write to disk first (ensures durability before memory)\n    await this.files.set(prefixedKey, value, expiresAt, entrySerialized);\n\n    // Write to memory if it fits\n    if (valueSize <= this.maxMemorySize) {\n      this.memory.set(prefixedKey, valueSerialized, expiresAt);\n    }\n  }\n\n  /**\n   * Delete a key from the cache.\n   */\n  async del(key: string): Promise<boolean> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n    this.cancelDebouncedTouch(prefixedKey);\n    const memDeleted = this.memory.delete(prefixedKey);\n    const diskDeleted = await this.files.delete(prefixedKey);\n    return memDeleted || diskDeleted;\n  }\n\n  /**\n   * Check if a key exists in the cache.\n   */\n  async exists(key: string): Promise<boolean> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n    return this.memory.has(prefixedKey) || (await this.files.has(prefixedKey));\n  }\n\n  /**\n   * Get all keys matching a pattern.\n   * @param pattern Glob-like pattern (supports * wildcard)\n   */\n  async keys(pattern = \"*\"): Promise<string[]> {\n    this.assertOpen();\n\n    // Prefix the pattern for internal lookup\n    const prefixedPattern = this.prefixKey(pattern);\n\n    const [memKeys, diskKeys] = await Promise.all([\n      Promise.resolve(this.memory.keys(prefixedPattern)),\n      this.files.keys(prefixedPattern),\n    ]);\n\n    // Remove prefix from returned keys\n    const allKeys = [...new Set([...memKeys, ...diskKeys])];\n    return allKeys.map((k) => this.unprefixKey(k));\n  }\n\n  /**\n   * Set expiration time in seconds.\n   */\n  async expire(key: string, seconds: number): Promise<boolean> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n    const expiresAt = Date.now() + seconds * 1000;\n\n    // Disk first - if this fails, don't update memory (keeps them consistent)\n    const diskSuccess = await this.files.setExpiry(prefixedKey, expiresAt);\n    if (!diskSuccess) {\n      return false;\n    }\n\n    // Memory second - best effort (memory is just a hot cache)\n    this.memory.setExpiry(prefixedKey, expiresAt);\n    return true;\n  }\n\n  /**\n   * Remove the TTL from a key, making it persistent.\n   * @returns true if TTL was removed, false if key doesn't exist\n   */\n  async persist(key: string): Promise<boolean> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n\n    // Disk first - if this fails, don't update memory (keeps them consistent)\n    const diskSuccess = await this.files.setExpiry(prefixedKey, null);\n    if (!diskSuccess) {\n      return false;\n    }\n\n    // Memory second - best effort (memory is just a hot cache)\n    this.memory.setExpiry(prefixedKey, null);\n    return true;\n  }\n\n  /**\n   * Touch a key: refresh its position in the LRU.\n   * This is more efficient than get() when you don't need the value.\n   * To update TTL, use expire() or pexpire() instead.\n   * @param key The cache key\n   * @returns true if key exists, false otherwise\n   */\n  async touch(key: string): Promise<boolean> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n\n    // Disk first - if this fails, key doesn't exist\n    const diskSuccess = await this.files.touch(prefixedKey);\n    if (!diskSuccess) {\n      return false;\n    }\n\n    // Memory second - best effort (memory is just a hot cache)\n    this.memory.touch(prefixedKey);\n    return true;\n  }\n\n  /**\n   * Get TTL in seconds.\n   * Returns -1 if no expiry, -2 if key not found.\n   */\n  async ttl(key: string): Promise<number> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n\n    const memTtlMs = this.memory.getTtl(prefixedKey);\n    if (memTtlMs !== -2) {\n      return memTtlMs < 0 ? memTtlMs : Math.ceil(memTtlMs / 1000);\n    }\n    const fileTtlMs = await this.files.getTtl(prefixedKey);\n    return fileTtlMs < 0 ? fileTtlMs : Math.ceil(fileTtlMs / 1000);\n  }\n\n  /**\n   * Get multiple values at once.\n   * Returns array in same order as keys (null for missing/expired).\n   */\n  async mget<T = unknown>(keys: string[]): Promise<(T | null)[]> {\n    return Promise.all(keys.map((key) => this.get<T>(key)));\n  }\n\n  /**\n   * Set multiple key-value pairs at once.\n   * Optimized to batch serialization and disk writes.\n   * @param entries Array of [key, value] or [key, value, ttl?] tuples (ttl in seconds)\n   */\n  async mset(entries: [string, unknown, number?][]): Promise<void> {\n    this.assertOpen();\n    if (entries.length === 0) return;\n\n    // Phase 1: Prepare all entries (serialization)\n    const prepared = entries.map(([key, value, ttl]) => {\n      const prefixedKey = this.prefixKey(key);\n      const resolvedTtl = this.resolveTtl(ttl);\n      const expiresAt = resolvedTtl ? Date.now() + resolvedTtl : null;\n\n      const valueSerialized = JSON.stringify(value);\n\n      // Guard against non-JSON-serializable values\n      if (valueSerialized === undefined) {\n        throw new TypeError(\n          `Cannot cache value of type ${typeof value} for key \"${key}\". Value must be JSON-serializable.`,\n        );\n      }\n\n      const valueSize = Buffer.byteLength(valueSerialized, \"utf8\");\n      const entrySerialized = `{\"key\":${JSON.stringify(prefixedKey)},\"value\":${valueSerialized},\"expiresAt\":${expiresAt}}`;\n\n      return { prefixedKey, value, expiresAt, valueSerialized, valueSize, entrySerialized };\n    });\n\n    // Phase 2: Write all to disk in parallel\n    await Promise.all(\n      prepared.map((p) => this.files.set(p.prefixedKey, p.value, p.expiresAt, p.entrySerialized)),\n    );\n\n    // Phase 3: Update memory (fast, synchronous operations)\n    for (const p of prepared) {\n      if (p.valueSize <= this.maxMemorySize) {\n        this.memory.set(p.prefixedKey, p.valueSerialized, p.expiresAt);\n      }\n    }\n  }\n\n  /**\n   * Get a value, or compute and set it if it doesn't exist (cache-aside pattern).\n   * Includes stampede protection - concurrent calls for the same key\n   * will wait for the first call to complete.\n   *\n   * @param key The cache key\n   * @param fn Function that computes the value to cache (can be async)\n   * @param ttl Optional TTL in seconds\n   */\n  async getOrSet<T>(key: string, fn: () => T | Promise<T>, ttl?: number): Promise<T> {\n    this.assertOpen();\n    const prefixedKey = this.prefixKey(key);\n\n    // Fast path: check cache first\n    const cached = await this.get<T>(key);\n    if (cached !== null) {\n      return cached;\n    }\n\n    return this.withStampedeProtection(prefixedKey, async () => {\n      // Double-check after acquiring \"lock\"\n      const recheck = await this.get<T>(key);\n      if (recheck !== null) {\n        return recheck;\n      }\n\n      const value = await fn();\n      await this.set(key, value, ttl);\n      return value;\n    });\n  }\n\n  /**\n   * Get the total number of items in the cache.\n   * This is the count of items on disk (source of truth).\n   */\n  async size(): Promise<number> {\n    this.assertOpen();\n    return this.files.getItemCount();\n  }\n\n  /**\n   * Remove all expired entries from the cache.\n   * This is called automatically if pruneInterval is configured.\n   * @returns Number of entries removed\n   */\n  async prune(): Promise<number> {\n    this.assertOpen();\n    // Prune both stores, but return disk count as source of truth\n    // (memory may have fewer items due to LRU eviction)\n    this.memory.prune();\n    return this.files.prune();\n  }\n\n  /**\n   * Get cache statistics.\n   */\n  async stats(): Promise<CacheStats> {\n    this.assertOpen();\n\n    const memStats = this.memory.stats;\n    const [diskSize, diskItemCount] = await Promise.all([\n      this.files.getSize(),\n      this.files.getItemCount(),\n    ]);\n\n    const total = this.hits + this.misses;\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      hitRate: total > 0 ? this.hits / total : 0,\n      memory: {\n        items: memStats.items,\n        size: memStats.size,\n        maxItems: memStats.maxItems,\n        maxSize: memStats.maxSize,\n      },\n      disk: {\n        items: diskItemCount,\n        size: diskSize,\n      },\n    };\n  }\n\n  /**\n   * Reset hit/miss counters.\n   */\n  resetStats(): void {\n    this.hits = 0;\n    this.misses = 0;\n  }\n\n  /**\n   * Clear all entries from the cache.\n   */\n  async clear(): Promise<void> {\n    this.assertOpen();\n    // Cancel all pending debounced touches\n    for (const timer of this.touchTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.touchTimers.clear();\n    this.memory.clear();\n    await this.files.clear();\n  }\n\n  /**\n   * Close the cache.\n   * After closing, all operations will throw.\n   */\n  async close(): Promise<void> {\n    if (this.pruneTimer) {\n      clearInterval(this.pruneTimer);\n      this.pruneTimer = undefined;\n    }\n    // Clear all pending touch timers\n    for (const timer of this.touchTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.touchTimers.clear();\n    this.closed = true;\n    this.inFlight.clear();\n  }\n}\n"],"mappings":"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"}